## 2진수를 4진수, 8진수, 16진수로 변환하기

예시: 01001011.1001(2)

2, 4, 8, 16진수 간의 변환은 2진수 표현에서 소수점을 기준으로 왼쪽과 오른쪽 양쪽으로 각각 2, 3, 4자리씩 묶습니다. 묶은 숫자는 각각 4, 8, 16진수의 한 자릿수가 됩니다. 양쪽 끝에서 빈 자리가 발생한다면 0으로 채워주면 됩니다.

- 2진수 -> 4진수
    - 01 00 10 11.10 01 = 1023.21(4)
- 2진수 -> 8진수
    - 001 001 011.100 100 = 113.44(8)
- 2진수 -> 16진수
    - 0100 1011.1001 = 4B.9(16)

## 컴퓨터 내부에서 뺄셈이 실행되는 과정

### 예시: 20 - 27 = ?

컴퓨터는 뺄셈 연산이 불가능하고 덧셈 연산만 가능합니다. 20-27=  20+(-27) 이므로, 20과 -27을 2진수로 바꾸어 가산해보도록 하겠습니다.
먼저, 10진수를 2진수로 바꾸고, 8비트로 표현해 줍니다.
20(10) = 00010100(2)
27(10) = 00011011(2)
음수를 계산하려면, 1의 보수를 더한 값에서 1을 더하는 방식으로 2의 보수를 구합니다. 
27(10) 1의 보수: 11100100(2)
27(10) 의 1의 보수에 1을 더한 값(2의 보수): 11100101(2)
두 수를 가산하면 아래와 같습니다.
00010100(2) + 11100101(2) = 11111001(2)
검산 과정은, 결과값 111110012의 부호를 나타내는 첫 번째 자리를 제외하고 2의 보수를 구해서 실제 뺀 값과 동일한지 확인해 보겠습니다.
11111001(2)의 2의 보수: 11111001(2) 1의 보수(10000110(2)) 에 1을 더한 값 10000111(2)
10000111(2) = - 710

## 10진수 57.875를 부동소수점 방식으로 실수 표현하기
(조건: 총 24bit 사용, 매직 넘버 127)

먼저, 주어진 값을 2진수로 변환합니다. 그리고 부동소수점으로 표현을 하기 위해서 정규화를 해줍니다.

57.875(10) = 111001.111(2) = 1.11001111(2) * 2^5

이를 통해 가수는 1.11001111이고, 지수는 5임을 알 수 있습니다. 이때 부호는 양수이므로 부호를 나타내는 값은 0이 됩니다.
24bit 부동소수점에서 매직 넘버가 128(=2^7)이므로, 지수를 표현하는 데에 8비트를 사용하게 됩니다. 부호 표현에는 1비트가 사용되고, 남은 15비트는 가수를 표현하는 데 사용됩니다.
지수를 표현하기 위해서는 매직넘버인 128을 5와 더해줍니다.
5 + 128(매직넘버) = 133 = 10000101(2)
정규화 거친 비트 중 유효숫자의 첫째자리는 언제나 1이므로 이를 제외하고 소수점 이하 부분만 가수 부분에 추가해줍니다. 남는 자리수는 0으로 채웁니다.

부호(1bit)  |   지수(8bit)  |	가수(15bit) 
0		   |    10000101    |   110011110000000 
